;DUC.per

;=========================<>=========================
;				       SCOUTING
;=========================<>=========================

    ;------------------
    ;   Claim Sheep
    ;------------------

        (defrule
        (true)
        =>
        (up-full-reset-search)
        )

        ;If sheep visible but unclaimed, claim sheep
        (defrule
        (up-gaia-type-count c: livestock-class > 0)
        (goal g-claim-sheep NO)
        (building-type-count town-center > 0)
        (goal g-gaia-sheep-id -1)
        =>
        (up-set-target-point g-position-self-x)
        (up-full-reset-search)
        (set-strategic-number sn-focus-player-number 0)
        (up-filter-distance c: -1 c: 30)
        (up-find-remote c: livestock-class c: 40)
        (up-remove-objects search-remote object-data-player != 0)   ;seems like up-find-remote considers all livestock owned by gaia
        (up-get-search-state g-local-total)
        )

        ;If we found sheep, tell scout to claim sheep
        (defrule
        (up-gaia-type-count c: livestock-class > 0)
        (up-set-target-object search-remote c: 0)
        (up-object-data object-data-class == livestock-class)
        (goal g-claim-sheep NO)
        (building-type-count town-center > 0)
        (goal g-gaia-sheep-id -1)
        =>
        (set-goal g-claim-sheep FOUND-SHEEP)
        (up-get-object-data object-data-id g-gaia-sheep-id)
        (up-modify-goal g-scouting-distance c:- 1)
        (up-chat-data-to-self "Reduce scouting distance to %d while claiming sheep" g: g-scouting-distance)
        )
        
        ;Find scout to claim sheep
        (defrule
        (up-gaia-type-count c: livestock-class > 0)
        (goal g-claim-sheep FOUND-SHEEP)
        (building-type-count town-center > 0)
        (up-set-target-by-id g: g-gaia-sheep-id)	;we found livestock within 30 tiles from TC
        =>
        (up-reset-search 1 1 0 0)   ;reset search-local but not search-remote
        (up-add-object-by-id search-local g: g-scout1-id)
        (up-add-object-by-id search-local g: g-scout2-id)
        (up-add-object-by-id search-local g: g-scout3-id)
        (up-remove-objects search-local object-data-class == livestock-class)   ;don't use our own sheep to claim other sheep
        (up-get-point position-object g-point-x)                                ;get location of unclaimed sheep
        (up-set-target-point g-point-x)
        (up-remove-objects search-local object-data-distance > 30)              ;remove scouts too far away from town
        (up-clean-search search-local object-data-distance search-order-asc)    ;find closest scout
        (up-remove-objects search-local object-data-index > 0)                  ;keep only one unit in search-local
        (up-get-search-state g-local-total)
        )
        
        ;Find scout or villager to claim sheep
        (defrule
        (up-gaia-type-count c: livestock-class > 0)
        (goal g-claim-sheep FOUND-SHEEP)
        (goal g-local-total 0)  ;we didn't find any scouts
        (building-type-count town-center > 0)
        (up-set-target-by-id g: g-gaia-sheep-id)	;we found livestock within 30 tiles from TC
        =>
        (up-reset-search 1 1 0 0)   ;reset search-local but not search-remote
        (up-get-point position-object g-point-x)                                ;get location of unclaimed sheep
        (up-set-target-point g-point-x)
        (up-find-local c: villager-class c: 10)                                 ;find villagers in case we don't have a scout at the moment or scout is too far
        (up-clean-search search-local object-data-distance search-order-asc)    ;find closest villager
        (up-remove-objects search-local object-data-distance > 30)              ;remove villager too far away from town
        (up-remove-objects search-local object-data-index > 0)                  ;keep only one unit in search-local
        (up-get-search-state g-local-total)
        )

        ;Task scout or villager to claim sheep
        ;Scout 1
        (defrule
        (up-gaia-type-count c: livestock-class > 0)
        (goal g-claim-sheep FOUND-SHEEP)
        (goal g-local-total 1)  ;found scout or villager
        (up-set-target-object search-local c: 0)
        (up-object-data object-data-id g:== g-scout1-id)    ;found scout 1
        (building-type-count town-center > 0)
        (up-set-target-by-id g: g-gaia-sheep-id)	;we found livestock within 30 tiles from TC
        =>
        (up-target-objects 0 action-move -1 -1)
        (set-goal g-claim-sheep SEND-SCOUT-1)
        (chat-local-to-self "scout 1 claim sheep")
        )
        ;Scout 2
        (defrule
        (up-gaia-type-count c: livestock-class > 0)
        (goal g-claim-sheep FOUND-SHEEP)
        (goal g-local-total 2)  ;found scout or villager
        (up-set-target-object search-local c: 0)
        (up-object-data object-data-id g:== g-scout2-id)    ;found scout 2
        (building-type-count town-center > 0)
        (up-set-target-by-id g: g-gaia-sheep-id)	;we found livestock within 30 tiles from TC
        =>
        (up-target-objects 0 action-move -1 -1)
        (set-goal g-claim-sheep SEND-SCOUT-2)
        (chat-local-to-self "scout 2 claim sheep")
        )
        ;Scout 3
        (defrule
        (up-gaia-type-count c: livestock-class > 0)
        (goal g-claim-sheep FOUND-SHEEP)
        (goal g-local-total 1)  ;found scout or villager
        (up-set-target-object search-local c: 0)
        (up-object-data object-data-id g:== g-scout3-id)    ;found scout 3
        (building-type-count town-center > 0)
        (up-set-target-by-id g: g-gaia-sheep-id)	;we found livestock within 30 tiles from TC
        =>
        (up-target-objects 0 action-move -1 -1)
        (set-goal g-claim-sheep SEND-SCOUT-3)
        (chat-local-to-self "scout 3 claim sheep")
        )
        ;Villager
        (defrule
        (up-gaia-type-count c: livestock-class > 0)
        (goal g-claim-sheep FOUND-SHEEP)
        (goal g-local-total 1)  ;found scout or villager
        (up-set-target-object search-local c: 0)
        (up-object-data object-data-class == villager-class)
        (building-type-count town-center > 0)
        (up-set-target-by-id g: g-gaia-sheep-id)	;we found livestock within 30 tiles from TC
        =>
        (up-target-objects 0 action-move -1 -1)
        (set-goal g-claim-sheep SEND-VILLAGER)
        (chat-local-to-self "villager claim sheep")
        )

        ;Check to see if we have claimed sheep
        (defrule
        (up-compare-goal g-claim-sheep >= FOUND-SHEEP)
        (building-type-count town-center > 0)
        (up-compare-goal g-gaia-sheep-id > -1)
        (up-set-target-by-id g: g-gaia-sheep-id)	;we found livestock within 30 tiles from TC
        =>
        (up-full-reset-search)
        (up-add-object-by-id search-remote g: g-gaia-sheep-id)
        (up-get-object-data object-data-player g-temp-3)
        (up-remove-objects search-remote object-data-player != 0)    ;removed the sheep if it belongs to another player besides gaia
        (up-get-search-state g-local-total)
        )

        ;If we have claimed sheep, reset g-scouting-status goal
        (defrule
        (up-compare-goal g-claim-sheep >= FOUND-SHEEP)
        (building-type-count town-center > 0)
        (up-compare-goal g-gaia-sheep-id > -1)
        (goal g-remote-total 0)	    ;the sheep has been claimed
        =>
        (set-goal g-claim-sheep NO)
        (set-goal g-gaia-sheep-id -1)
        (chat-local-to-self "ready to claim sheep again")
        )

    ;-------------------------------------------
    ;   Initial Scouting For Resources
    ;-------------------------------------------

	(defrule
	(up-compare-goal g-duc-scouting != STOP-DUC-SCOUTING)
	(or
		(not
			(up-set-target-by-id g: g-scout1-id))
		(or
			(building-type-count-total town-center == 0)
			(game-time s:>= sn-home-exploration-time)))
	(game-time >= 5)
	=>
	(set-goal g-duc-scouting STOP-DUC-SCOUTING)
	)

    ;Send scout(s) to explore in circles around the town center

    ;This section allows for up to three units to explore with DUC simultaneously by looping through each scout

        ;Prepare for loop
        (defrule
        (or
            (up-set-target-by-id g: g-scout1-id)
            (or
                (up-set-target-by-id g: g-scout2-id)
                (up-set-target-by-id g: g-scout3-id)))
        (up-compare-goal g-duc-scouting != STOP-DUC-SCOUTING)
        =>
        (set-goal i 1)                                          ;increments through each scout (1 = first scout, 2 = second scout, 3 = third scout)
        (set-goal g-current-scout-goal g-scout1-id)
        (up-modify-goal g-current-scout-id g:= g-scout1-id)
        )

        ;-------------------
        ;   LOOP SECTION!
        ;-------------------

            ;Skip rules if the current scout (1, 2, or 3) isn't set

            (defrule
            (or
                (not
                    (up-set-target-by-id g: g-current-scout-id))   ;either scout 1, 2, or 3 depending on the loop
                (or
                    (goal g-duc-scouting STOP-DUC-SCOUTING)
                    (nor
                            (goal g-scouting-status FIND-RESOURCES)
                            (goal g-scouting-status SCOUT-TOWN))))
            =>
            (up-jump-rule 28)
            )

            ;Skip rules if current scout is claiming sheep

            (defrule
            (or
                (and
                    (goal i 1)  ;loop is looking at first scout
                    (goal g-claim-sheep SEND-SCOUT-1))
                (or
                    (and
                        (goal i 2)  ;loop is looking at second scout
                        (goal g-claim-sheep SEND-SCOUT-2))
                    (and
                        (goal i 3)  ;loop is looking at third scout
                        (goal g-claim-sheep SEND-SCOUT-3))))
            =>
            (up-jump-rule 27)
            )

            ;Reset g-duc-scouting
            (defrule
            (up-compare-goal g-duc-scouting != STOP-DUC-SCOUTING)
            =>
            (set-goal g-duc-scouting RESET)
            (set-goal g-temp 0)
            (set-goal g-temp-2 0)
            (set-goal g-temp-3 0)
            (set-goal g-point-x -1)
            (set-goal g-point-y -1)
            (set-goal g-point2-x -1)
            (set-goal g-point2-y -1)
            )

            ;---------------------------------------------------------
            ;   Check if current scout is tasked to explore a point
            ;---------------------------------------------------------

                ;Check if scout 1 is targeting a point
                (defrule
                (goal g-duc-scouting RESET)
                (up-set-target-by-id g: g-current-scout-id)
                (goal i 1)
                (up-compare-flag g-flag == SCOUT-1-TARGET-SET)
                =>
                (set-goal g-duc-scouting TARGETING-POINT)
                (up-copy-point g-point-x g-scout1-target-x)     ;copy scout 1's target location into g-point-x
                )
                ;Check if scout 2 is targeting a point
                (defrule
                (goal g-duc-scouting RESET)
                (up-set-target-by-id g: g-current-scout-id)
                (goal i 2)
                (up-compare-flag g-flag == SCOUT-2-TARGET-SET)
                =>
                (set-goal g-duc-scouting TARGETING-POINT)
                (up-copy-point g-point-x g-scout2-target-x)     ;copy scout 2's target location into g-point-x
                )
                ;Check if scout 3 is targeting a point
                (defrule
                (goal g-duc-scouting RESET)
                (up-set-target-by-id g: g-current-scout-id)
                (goal i 3)
                (up-compare-flag g-flag == SCOUT-3-TARGET-SET)
                =>
                (set-goal g-duc-scouting TARGETING-POINT)
                (up-copy-point g-point-x g-scout3-target-x)     ;copy scout 3's target location into g-point-x
                )

            ;----------------------------
            ;   Get Next Explore Point
            ;----------------------------

                ;Set the scout's position and the up-cross-tiles distance and direction
                (defrule
                (goal g-duc-scouting RESET)
                (up-set-target-by-id g: g-current-scout-id)   ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                =>
                (set-goal g-duc-scouting START)
                (up-get-point position-object g-point-x)            ;Store the scout's position, will be changed to the next point to be explored
                (set-goal g-temp 9)                                 ;distance for up-cross-tiles in next rule
                (up-modify-goal g-temp-2 g:= i)                     ;make sure scout 2 goes in opposite direction from scout 1 and 3, i = current scout in loop
                (up-modify-goal g-temp-2 c:mod 2)                   ;if i = 1 or 3, then result = 1; if i = 2, then result = 0
                (up-modify-goal g-temp-2 c:* 2)                     ;if i = 1 or 3, then result = 2; if i = 2, then result = 0
                (up-modify-goal g-temp-2 c:- 1)                     ;if i = 1 or 3, then result = 1, if i = 2, then result = -1
                (up-modify-goal g-temp g:* g-temp-2)                ;if i = 2, then g-temp will be negated, which will switch the direction in next rule
                (up-modify-goal g-temp g:* g-scouting-direction)    ;clockwise = -1, counterclockwise = 1)
                )

                ;Set next explore point
                (defrule
                (goal g-duc-scouting START)
                (up-set-target-by-id g: g-current-scout-id)   ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                =>
                (up-get-point position-object g-point-x)
                (up-cross-tiles g-point-x g-position-self-x g: g-temp)              ;this gets a point 9 tiles away (value of g-temp) that is perpendicular to the line drawn between the scout and the TC
                (up-bound-point g-point-x g-point-x)                                ;make sure point is on the map
                (up-copy-point g-point2-x g-position-self-x)                        ;store the TC location in g-point2-x
                (up-lerp-tiles g-point2-x g-point-x g: g-scouting-distance)         ;get a point g-scouting-distance tiles away from g-point2-x (TC location) toward g-point-x (scouting target), store in g-point2-x
                (up-bound-point g-point2-x g-point2-x)                              ;bound the new point on the map and store it in g-point2-x
                (set-goal g-duc-scouting SET-POINT)
                (up-get-path-distance g-point2-x 0 g-temp-2)                        ;store path distance from scout to the point in g-temp-2
                )
                    
                (defrule
                (goal g-duc-scouting START)
                (up-set-target-by-id g: g-current-scout-id)   ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                =>
                (set-goal g-temp-3 1)   ;used to track iterations in the following loop, if it takes more than 10 tries to find an accessible point, switch to auto scouting
                )

                    ;Check if explore point is accessible
                    (defrule
                    (up-compare-goal g-temp-3 < 10)
                    (goal g-duc-scouting SET-POINT)
                    (up-set-target-by-id g: g-current-scout-id)   ;current scout found and is alive
                    (building-type-count-total town-center > 0)
                    (or
                        (goal g-scouting-status FIND-RESOURCES)
                        (goal g-scouting-status SCOUT-TOWN))
                    (goal g-temp-2 65535)   ;explore point is inaccessible
                    =>
                    (chat-local-to-self "point inaccessible, find new point")
                    )

                    (defrule
                    (up-compare-goal g-temp-3 < 10)
                    (goal g-duc-scouting SET-POINT)
                    (up-set-target-by-id g: g-current-scout-id)   ;current scout found and is alive
                    (building-type-count-total town-center > 0)
                    (or
                        (goal g-scouting-status FIND-RESOURCES)
                        (goal g-scouting-status SCOUT-TOWN))
                    (goal g-temp-2 65535)   ;explore point is inaccessible
                    =>
                    (up-cross-tiles g-point2-x g-position-self-x g: g-temp)             ;this gets a point 9 tiles away (value of g-temp) that is perpendicular to the line drawn between the scout and the TC
                    (up-bound-point g-point2-x g-point2-x)                              ;make sure point is on the map
                    (up-copy-point g-point-x g-position-self-x)                         ;store the TC location in g-point2-x
                    (up-lerp-tiles g-point-x g-point2-x g: g-scouting-distance)         ;get a point g-scouting-distance tiles away from g-point-x (TC location) toward g-point2-x (scouting target), store in g-point-x
                    (up-bound-point g-point2-x g-point-x)                               ;bound the new point on the map and store it in g-point2-x
                    (up-get-path-distance g-point2-x 0 g-temp-2)                        ;store path distance from scout to the point in g-temp-2
                    (up-modify-goal g-temp-3 c:+ 1)
                    (up-jump-rule -2)
                    )

                ;If accessible point can't be found, switch to auto scouting
                (defrule
                (goal g-temp-3 10)  ;couldn't find accessible point
                (goal g-duc-scouting SET-POINT)
                (up-set-target-by-id g: g-current-scout-id)   ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (goal g-temp-2 65535)   ;explore point is inaccessible
                =>
                (up-reset-scouts)
                (set-goal g-duc-scouting STOP-DUC-SCOUTING)
                )

                ;Send Scout 1 to the explore point
                (defrule
                (goal i 1)                                      ;first scout
                (goal g-duc-scouting SET-POINT)
                (up-set-target-by-id g: g-current-scout-id)     ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (up-compare-goal g-point2-x >= 0)   ;point is valid
                (up-compare-goal g-point2-y >= 0)
                =>
                (up-copy-point g-scout1-target-x g-point2-x)                ;copy explore point into g-scout1-target-x
                (up-full-reset-search)
                (up-add-object-by-id search-local g: g-current-scout-id)    ;add current scout to search-local
                (up-target-point g-scout1-target-x action-move -1 -1)       ;send scout to the next explore point
                (up-modify-flag g-flag c:+ SCOUT-1-TARGET-SET)
                (set-goal g-duc-scouting TARGETING-POINT)
                )
                ;Send Scout 2 to the explore point
                ;Set point 6 tiles further than g-scouting-distance so that exploration doesn't overlap with scout 1
                (defrule
                (goal i 2)                                      ;second scout
                (goal g-duc-scouting SET-POINT)
                (up-set-target-by-id g: g-current-scout-id)     ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (up-compare-goal g-point2-x >= 0)   ;point is valid
                ;(up-compare-goal g-point2-y >= 0)
                =>
                (up-copy-point g-scout2-target-x g-point2-x)                ;copy explore point into g-scout2-target-x
                (up-lerp-tiles g-scout2-target-x g-position-self-x c: -6)   ;set explore point 6 tiles further away from TC
                (up-bound-point g-scout2-target-x g-scout2-target-x)
                (up-full-reset-search)
                (up-add-object-by-id search-local g: g-current-scout-id)    ;add current scout to search-local
                (up-target-point g-scout2-target-x action-move -1 -1)       ;send scout to the next explore point
                (up-modify-flag g-flag c:+ SCOUT-2-TARGET-SET)
                (set-goal g-duc-scouting TARGETING-POINT)
                )
                ;Send Scout 3 to the explore point
                ;Set point 12 tiles further than g-scouting-distance so that exploration doesn't overlap with scout 1 or scout 2
                (defrule
                (goal i 3)                                      ;third scout
                (goal g-duc-scouting SET-POINT)
                (up-set-target-by-id g: g-current-scout-id)     ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (up-compare-goal g-point2-x >= 0)   ;point is valid
                ;(up-compare-goal g-point2-y >= 0)
                =>
                (up-copy-point g-scout3-target-x g-point2-x)                ;copy explore point into g-scout3-target-x
                (up-lerp-tiles g-scout3-target-x g-position-self-x c: -12)  ;set explore point 12 tiles further away from TC
                (up-bound-point g-scout3-target-x g-scout3-target-x)
                (up-full-reset-search)
                (up-add-object-by-id search-local g: g-current-scout-id)    ;add current scout to search-local
                (up-target-point g-scout3-target-x action-move -1 -1)       ;send scout to the next explore point
                (up-modify-flag g-flag c:+ SCOUT-3-TARGET-SET)
                (set-goal g-duc-scouting TARGETING-POINT)
                )

            ;----------------------
            ;   Switch Direction
            ;----------------------

                ;If explore point is on the border, switch the scouting direction for the next explore point
                ;For convenience, only switch direction when scout 1 reaches the border

                ;If the explore point is near NW or SW border
                (defrule
                (goal i 1)                                      ;First scout in loop
                (game-time > 90)                                ;allow exploring along border if scouting reaches the border early, we likely started near the border of the map, so we want to guarantee that we explore it
                (goal g-duc-scouting TARGETING-POINT)
                (up-set-target-by-id g: g-current-scout-id)     ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (or
                    (up-compare-goal g-scout1-target-x <= 2)
                    (up-compare-goal g-scout1-target-y <= 2))     ;the point is <= 2 tiles away from the NW or SW border
                (timer-triggered t-change-scouting-direction)
                =>
                (up-modify-goal g-scouting-direction c:* -1)    ;switch direction (clockwise = -1, counterclockwise = 1)
                (enable-timer t-change-scouting-direction 30)
                (up-modify-goal g-scouting-distance c:+ 3)
                (chat-local-to-self "Change scouting direction")
                )
                
                ;If the explore point is near NE or SE border
                (defrule
                (goal i 1)                                      ;First scout in loop
                (game-time > 90)                                ;allow exploring along border if scouting reaches the border early, we likely started near the border of the map, so we want to guarantee that we explore it
                (goal g-duc-scouting TARGETING-POINT)
                (up-set-target-by-id g: g-current-scout-id)     ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (or
                    (up-compare-goal g-scout1-target-x >= HUNDRED-PERCENT-MAP-SIZE-MINUS-TWO)
                    (up-compare-goal g-scout1-target-y >= HUNDRED-PERCENT-MAP-SIZE-MINUS-TWO))    ;the point is <= 2 tiles away from the NE or SE border
                (timer-triggered t-change-scouting-direction)
                =>
                (up-modify-goal g-scouting-direction c:* -1)    ;switch direction (clockwise = -1, counterclockwise = 1)
                (enable-timer t-change-scouting-direction 30)
                (chat-local-to-self "Change scouting direction")
                )

            ;-------------------------------------
            ;   Check Distance To Explore Point
            ;-------------------------------------

                (defrule
                (goal g-duc-scouting TARGETING-POINT)
                =>
                (set-goal g-point-x -1)
                (set-goal g-point-y -1)
                (set-goal g-temp 0)
                (set-goal g-temp-2 0)
                )

                ;Store explore point in g-point-x
                (defrule
                (goal i 1)
                (goal g-duc-scouting TARGETING-POINT)
                (up-compare-goal g-scout1-target-x >= 0)
                (up-compare-goal g-scout1-target-y >= 0)
                =>
                (up-copy-point g-point-x g-scout1-target-x)
                )
                (defrule
                (goal i 2)
                (goal g-duc-scouting TARGETING-POINT)
                (up-compare-goal g-scout2-target-x >= 0)
                (up-compare-goal g-scout2-target-y >= 0)
                =>
                (up-copy-point g-point-x g-scout2-target-x)
                )
                (defrule
                (goal i 3)
                (goal g-duc-scouting TARGETING-POINT)
                (up-compare-goal g-scout3-target-x >= 0)
                (up-compare-goal g-scout3-target-y >= 0)
                =>
                (up-copy-point g-point-x g-scout3-target-x)
                )
                
                ;Check to see if scout is idle and get distance to target point
                (defrule
                (goal g-duc-scouting TARGETING-POINT)
                (up-set-target-by-id g: g-current-scout-id)     ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (up-compare-goal g-point-x >= 0)
                (up-compare-goal g-point-y >= 0)
                =>
                (up-get-object-data object-data-idling g-temp-2)
                (up-get-path-distance g-point-x 0 g-temp)                        ;store path distance from scout to the point in g-temp-2
                ;(up-chat-data-to-self "Dist %d" g: g-temp)
                )

                ;Reset scouting if current scout is idle
                ;Scout 1
                (defrule
                (goal i 1)
                (goal g-duc-scouting TARGETING-POINT)
                (up-set-target-by-id g: g-current-scout-id)     ;scout is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (goal g-temp-2 1)                               ;scout is idle
                =>
                (chat-local-to-self "scout 1 is idle")
                (set-goal g-duc-scouting RESET)
                (up-modify-flag g-flag c:- SCOUT-1-TARGET-SET)
                )
                ;Scout 2
                (defrule
                (goal i 2)
                (goal g-duc-scouting TARGETING-POINT)
                (up-set-target-by-id g: g-current-scout-id)     ;scout is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (goal g-temp-2 1)                               ;scout is idle
                =>
                (chat-local-to-self "scout 2 is idle")
                (set-goal g-duc-scouting RESET)
                (up-modify-flag g-flag c:- SCOUT-2-TARGET-SET)
                )
                ;Scout 3
                (defrule
                (goal i 3)
                (goal g-duc-scouting TARGETING-POINT)
                (up-set-target-by-id g: g-current-scout-id)     ;scout is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (goal g-temp-2 1)                               ;scout is idle
                =>
                (chat-local-to-self "scout 3 is idle")
                (set-goal g-duc-scouting RESET)
                (up-modify-flag g-flag c:- SCOUT-3-TARGET-SET)
                )

                ;If scout has a distance of <= 2 from g-scout-position-x, get new point

                ;Scout 1
                (defrule
                (goal i 1)
                (goal g-duc-scouting TARGETING-POINT)
                (up-set-target-by-id g: g-current-scout-id)     ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (goal g-temp-2 0)                               ;scout isn't idle
                (up-compare-goal g-temp <= 2)                   ;scout is close to the explore point
                =>
                (set-goal g-duc-scouting RESET)
                (up-modify-flag g-flag c:- SCOUT-1-TARGET-SET)
                (chat-local-to-self "get new point, scout 1")
                )
                ;Scout 2
                (defrule
                (goal i 2)
                (goal g-duc-scouting TARGETING-POINT)
                (up-set-target-by-id g: g-current-scout-id)     ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (goal g-temp-2 0)                               ;scout isn't idle
                (up-compare-goal g-temp <= 2)                   ;scout is close to the explore point
                =>
                (set-goal g-duc-scouting RESET)
                (up-modify-flag g-flag c:- SCOUT-2-TARGET-SET)
                (chat-local-to-self "get new point, scout 2")
                )
                ;Scout 3
                (defrule
                (goal i 3)
                (goal g-duc-scouting TARGETING-POINT)
                (up-set-target-by-id g: g-current-scout-id)     ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (goal g-temp-2 0)                               ;scout isn't idle
                (up-compare-goal g-temp <= 2)                   ;scout is close to the explore point
                =>
                (set-goal g-duc-scouting RESET)
                (up-modify-flag g-flag c:- SCOUT-3-TARGET-SET)
                (chat-local-to-self "get new point, scout 3")
                )

                ;If point is unreachable but far away, assume DUC scouting is no longer efficient
                
                (defrule
                (goal g-duc-scouting TARGETING-POINT)
                (up-set-target-by-id g: g-current-scout-id)     ;current scout found and is alive
                (building-type-count-total town-center > 0)
                (or
                    (goal g-scouting-status FIND-RESOURCES)
                    (goal g-scouting-status SCOUT-TOWN))
                (up-compare-goal g-temp != 65535)   ;path-distance is != 65535, point is reachable
                (up-compare-goal g-temp >= 50)      ;path-distance is far away, stop DUC scouting
                (up-compare-goal g-scouting-distance >= 18)
                =>
                (chat-to-player my-player-number "stop DUC scouting, next point far away")
                (up-reset-scouts)
                (set-goal g-duc-scouting STOP-DUC-SCOUTING)
                )

            ;------------------------
            ;   Next Scout in Loop
            ;------------------------

            (defrule
            (up-compare-goal i < 3)
            (up-compare-goal g-duc-scouting != STOP-DUC-SCOUTING)
            =>
            (up-modify-goal i c:+ 1)
            (up-modify-goal g-current-scout-goal c:+ 1)
            (up-get-indirect-goal g: g-current-scout-goal g-current-scout-id)
            (set-goal g-temp -1)
            (set-goal g-temp-2 -1)
            (set-goal g-temp-3 -1)
            (set-goal g-point-x -1)
            (set-goal g-point-y -1)
            (up-jump-rule -30)
            )

    ;---------------
    ;   Sheep DUC
    ;---------------

    ;This section controls the movement of sheep and how villagers gather the sheep

        ;Move current sheep to TC
        (defrule
        (building-type-count town-center == 1)
        =>
        (up-set-target-point g-position-self-x)
        (up-full-reset-search)
        (set-goal g-point-x -1)
        (set-goal g-point-y -1)
        (set-goal g-temp -1)
        (set-goal g-temp-2 -1)
        (set-goal g-temp-3 -1)
        (up-get-search-state g-local-total)
        )

        (defrule
        (building-type-count town-center == 1)
        (up-set-target-by-id g: g-sheep-currently-gathering-id)
        (up-object-data object-data-idling == 1)	;current sheep is idle
        (up-object-data object-data-distance >= 3)	;current sheep too far away from TC
        (up-object-data object-data-hitpoints > 0)
        =>
        (up-get-point position-self g-point-x)
        (up-modify-goal g-point-x c:- 1)			;Get point a little bit away from the TC center
        (up-bound-point g-point-x g-point-x)
        (up-set-target-point g-point-x)
        (up-full-reset-search)
        (up-add-object-by-id search-local g: g-sheep-currently-gathering-id)
        (up-target-point g-point-x action-default -1 -1)
        (chat-local-to-self "Send current sheep to TC")
        )

        ; ;Move next sheep to TC when the current sheep is almost done
        ; (defrule
        ; (building-type-count town-center == 1)
        ; (up-set-target-by-id g: g-sheep-currently-gathering-id)
        ; (up-object-data object-data-hitpoints == 0)	;current sheep is dead
        ; =>
        ; (up-get-point position-self g-point-x)
        ; (up-modify-goal g-point-x c:- 1)			;Get point a little bit away from the TC center
        ; (up-bound-point g-point-x g-point-x)
        ; (up-set-target-point g-point-x)
        ; (up-get-object-data object-data-carry g-temp-3)
        ; )

        ;Detect how many sheep we have, only send sheep if we have < 2 dead sheep
        (defrule
        (building-type-count town-center == 1)
        (up-set-target-by-id g: g-sheep-currently-gathering-id)
        =>
        (up-full-reset-search)
        (up-set-target-point g-position-self-x)
        (up-filter-status c: status-gather c: list-active)
        (up-filter-distance c: -1 c: 10)
        (set-strategic-number sn-focus-player-number 0)
        (up-find-status-remote c: livestock-class c: 2)
        (up-get-search-state g-local-total)
        (up-filter-status c: status-ready c: list-active)
        ;(up-chat-data-to-self "Dead sheep %d" g: g-remote-total)
        )

        ;Pick a point to send sheep to
        (defrule
        (building-type-count town-center == 1)
        (up-set-target-by-id g: g-sheep-currently-gathering-id)
        (up-object-data object-data-hitpoints == 0)	;current sheep is dead
        (or
            (up-object-data object-data-point-x g:!= g-point-x)
            (up-object-data object-data-point-y g:!= g-point-y))
        (or
            (up-object-data object-data-carry < 25)
            (unit-type-count villager-shepherd > 6))    ;having more than 6 shepherds usually causes crowding
        (up-set-target-by-id g: g-sheep-next-gathering-id)
        (up-object-data object-data-idling == 1)	;next sheep is idle
        (up-object-data object-data-distance >= 3)	;next sheep too far away from TC
        (up-compare-goal g-remote-total < 2)         ;we have less than two dead sheep
        =>
        (up-set-target-point g-position-self-x)
        (set-goal g-temp-2 865)
        )

        (defrule
        (building-type-count town-center == 1)
        (up-set-target-by-id g: g-sheep-currently-gathering-id)
        (up-object-data object-data-hitpoints == 0)	;current sheep is dead
        (up-object-data object-data-point-x g:== g-point-x)
        (up-object-data object-data-point-y g:== g-point-y)
        (or
            (up-object-data object-data-carry < 25)
            (unit-type-count villager-shepherd > 6))    ;having more than 6 shepherds usually causes crowding
        (up-set-target-by-id g: g-sheep-next-gathering-id)
        (up-object-data object-data-idling == 1)	;next sheep is idle
        (up-object-data object-data-distance >= 3)	;next sheep too far away from TC
        (up-compare-goal g-remote-total < 2)         ;we have less than two dead sheep
        =>
        (up-set-target-point g-position-self-x)
        (set-goal g-temp-2 866)
        )

        ;Default spot isn't occupied by currently gathered sheep, send sheep there
        (defrule
        (building-type-count town-center == 1)
        (up-set-target-by-id g: g-sheep-next-gathering-id)
        (up-object-data object-data-idling == 1)	;next sheep is idle
        (up-object-data object-data-distance >= 3)	;next sheep too far away from TC
        (goal g-temp-2 865)
        =>
        (up-get-point position-self g-point-x)
        (up-modify-goal g-point-x c:- 1)			;Get point a little bit away from the TC center
        (up-bound-point g-point-x g-point-x)
        (up-set-target-point g-point-x)
        (up-add-object-by-id search-local g: g-sheep-next-gathering-id)
        (up-target-point g-point-x action-default -1 -1)
        (chat-local-to-self "Send next sheep to TC, point 1")
        )

        ;Default spot is covered, send sheep to different spot
        (defrule
        (building-type-count town-center == 1)
        (up-set-target-by-id g: g-sheep-next-gathering-id)
        (up-object-data object-data-idling == 1)	;next sheep is idle
        (up-object-data object-data-distance >= 3)	;next sheep too far away from TC
        (goal g-temp-2 866)
        =>
        (up-get-point position-self g-point-x)
        (up-modify-goal g-point-y c:+ 1)			;Get point a little bit away from the TC center
        (up-bound-point g-point-x g-point-x)
        (up-set-target-point g-point-x)
        (up-add-object-by-id search-local g: g-sheep-next-gathering-id)
        (up-target-point g-point-x action-default -1 -1)
        (chat-local-to-self "Send next sheep to TC, point 2")
        )

        ;Get sheep to send to sheep gather point (exclude the current sheep to gather)
        (defrule
        (building-type-count town-center == 1)
        (up-compare-goal g-sheep-current-count > 0)
        =>
        (up-set-target-point g-sheep-gather-x)
        (up-full-reset-search)
        (up-filter-distance c: 3 c: -1)
        (up-find-local c: livestock-class c: 10)
        (up-remove-objects search-local object-data-id g:== g-sheep-currently-gathering-id)
        (up-remove-objects search-local object-data-id g:== g-scout2-id)
        (up-remove-objects search-local object-data-id g:== g-scout3-id)
        (up-get-search-state g-local-total)
        )

        ;Exclude the next sheep to gather if the current sheep is almost completely gathered
        (defrule
        (building-type-count town-center == 1)
        (up-compare-goal g-sheep-current-count > 0)
        (up-set-target-by-id g: g-sheep-currently-gathering-id)
        (or
            (up-object-data object-data-carry < 25)
            (unit-type-count villager-shepherd > 6))    ;having more than 6 shepherds usually causes crowding
        =>
        (up-remove-objects search-local object-data-id g:== g-sheep-next-gathering-id)
        (up-get-search-state g-local-total)
        )

        ;Send sheep to sheep gather point
        (defrule
        (building-type-count town-center == 1)
        (up-compare-goal g-sheep-current-count > 0)
        (up-compare-goal g-local-total > 0)
        =>
        (up-set-target-point g-sheep-gather-x)
        (up-target-point g-sheep-gather-x action-default -1 -1)
        )

        ;Retask shepherds if they target a sheep too far from town center

        ;First, determine if any sheep are incorrectly being targeted
        (defrule
        (building-type-count town-center == 1)
        (unit-type-count livestock-class > 0)
        =>
        (up-set-target-point g-position-self-x)
        (set-goal g-point-x -1) ;reset stuff just in case
        (set-goal g-point-y -1)
        (set-goal g-temp -1)
        (set-goal g-temp-2 -1)
        (set-goal g-temp-3 -1)
        (up-full-reset-search)
        (up-filter-distance c: 4 c: -1)
        (set-strategic-number sn-focus-player-number my-player-number)
        (up-find-remote c: livestock-class c: 20)
        (up-remove-objects search-remote object-data-tasks-count == 0)
        (up-remove-objects search-remote object-data-player != my-player-number)
        (up-get-search-state g-local-total)
        )

        ;If so, get villagers that are targeting the sheep
        (defrule
        (building-type-count town-center == 1)
        (unit-type-count livestock-class > 0)
        (up-compare-goal g-remote-total > 0)
        (up-set-target-object search-remote c: 0)
        (up-get-object-data object-data-id g-temp)  ;store sheep ID that is incorrectly being targeted
        =>
        (up-reset-search 1 1 0 0)
        (up-reset-filters)
        (up-find-local c: villager-class c: 120)
        (up-set-target-object search-local c: 0)
        (up-get-object-data object-data-target-id g-temp-2)
        (up-remove-objects search-local object-data-target-id g:!= g-temp)  ;remove villagers not targeting the sheep
        (chat-local-to-self "found shepherds targeting wrong sheep")
        (up-get-search-state g-local-total)
        )

        (defrule
        (building-type-count town-center == 1)
        (unit-type-count livestock-class > 0)
        (up-compare-goal g-remote-total > 0)
        (up-set-target-object search-remote c: 0)
        (up-set-target-by-id g: g-sheep-currently-gathering-id)
        (up-object-data object-data-distance <= 4)
        (up-compare-goal g-local-total > 0)
        =>
        (up-target-objects 1 action-default -1 -1)
        (chat-local-to-self "retask shepherd to current sheep")
        )

        ;If sheep isn't close, garrison shepherds in TC to send them toward the TC and/or retask them
        (defrule
        (building-type-count town-center == 1)
        (unit-type-count livestock-class > 0)
        (up-compare-goal g-remote-total > 0)
        (up-set-target-object search-remote c: 0)
        (or
            (not
                (up-set-target-by-id g: g-sheep-currently-gathering-id))
            (up-object-data object-data-distance > 4))
        (up-compare-goal g-local-total > 0)
        =>
        (up-reset-search 0 0 1 1)
        (up-reset-filters)
        (up-find-remote c: town-center c: 1)
        (up-target-objects 0 action-garrison -1 -1)
        (chat-local-to-self "garrison shepherds to retask")
        )

        (defrule
        (true)
        =>
        (set-goal g-temp-2 -1)
        )

    ;-------------------
    ;   TC Ungarrison
    ;-------------------

        ;This forces a speedy ungarrison for when villagers are tasked to garrison in the TC to be retasked

        (defrule
        (building-type-count town-center > 0)
        (goal g-town-under-attack NO)
        (up-enemy-units-in-town == 0)
        (up-enemy-buildings-in-town == 0)
        =>
        (up-full-reset-search)
        (up-filter-garrison c: 1 c: -1)
        (up-find-local c: town-center c: 5)
        (up-target-point 0 action-ungarrison -1 -1)
        )